<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIDSX: MIDSX (Monte Carlo Interactions and Dosage Simulation of X-rays)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MIDSX<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">A x-ray transport code system for dosimetry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MIDSX (Monte Carlo Interactions and Dosage Simulation of X-rays) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a><img src="https://img.shields.io/github/contributors/jmeneghini/MIDSX" alt="Contributors" class="inline"/> <img src="https://img.shields.io/github/forks/jmeneghini/MIDSX" alt="Forks" class="inline"/> <img src="https://img.shields.io/github/stars/jmeneghini/MIDSX" alt="Stars" class="inline"/> <img src="https://img.shields.io/github/issues/jmeneghini/MIDSX" alt="Issues" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li>Description</li>
<li>Getting Started<ul>
<li>Dependencies</li>
<li>Installation</li>
</ul>
</li>
<li>Documentation</li>
<li>Usage</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Description</h1>
<p>MIDSX is a code system for simulating the propagation of X-rays through a medium. Using <a href="https://www-nds.iaea.org/epics/">EPDL</a> and <a href="https://www.nist.gov/pml/x-ray-mass-attenuation-coefficients">NIST</a> datasets, it samples photon free paths and interactions to propagate photons through a computational domain of specified dimensions and geometries. Geometries/bodies are defined using the <a href="https://nifti.nimh.nih.gov/nifti-1">NIfTI-1 Data Format</a>, which are specified in JSON files. To extract results from a simulation, both Volume and Surface tallies with specifiable measurable quantities and geometries are available, along with derived quantities, such as air kerma for HVL measurements. The following project is a <b>WIP</b>, so documentation is currently not available, but it is in the works.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Getting Started</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Dependencies</h2>
<p>MIDSX requires the following dependencies to be manually installed:</p>
<ul>
<li><b>CMake 3.10.0 or higher:</b> If you don't have CMake installed, or require a newer version, follow this <a href="https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line">guide</a>.</li>
<li><b>SQLite3 Library:</b> On Linux, the library can be installed using your distribution's package manager. Using apt: <code>sudo apt install sqlite3 libsqlite3-dev</code>. On Mac, the library can be installed with brew: <code>brew install sqlite3 libsqlite3-dev</code>.</li>
<li><b>Python 3.8.x or higher:</b> If not already installed, go <a href="https://www.python.org/downloads/">here</a>.</li>
<li><b>nibabel:</b> To load NifTI files, MIDSX uses the python package nibabel. It can be easily installed with pip: <code>pip install nibabel</code>.</li>
</ul>
<p>MIDSX additionally uses the following libraries via Git submodules; these do not need to be installed manually:</p>
<ul>
<li><b>Eigen:</b> For data storage and linear algebra.</li>
<li><b>pybind11:</b> For use of nibabel in C++ code. Will be used later for MIDSX python bindings.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Installation</h2>
<p>MIDSX has been tested on macOS and Ubuntu. To install with the command line:</p>
<ol type="1">
<li>Clone the repo and enter the directory: <div class="fragment"><div class="line">git clone https://github.com/jmeneghini/MIDSX.git</div>
<div class="line">cd MIDSX</div>
</div><!-- fragment --></li>
<li>Create and enter the build directory: <div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
</div><!-- fragment --></li>
<li>Generate cmake files and install: <div class="fragment"><div class="line">cmake ..</div>
<div class="line">sudo make install</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
Documentation</h1>
<p>The <a href="https://jmeneghini.github.io/MIDSX/">documentation</a> for MIDSX is generated via Doxygen and is hosted with Github Pages. \ \ The preprint for the validation of MIDSX can be found on <a href="https://arxiv.org/abs/2311.16873">arXiv</a>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Usage</h1>
<p>To use the library, configure a project with the following CMakeLists.txt structure:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.10)</div>
<div class="line">project(project_name)</div>
<div class="line"> </div>
<div class="line"># Links libraries and turns off parallelization if building in debug mode</div>
<div class="line">function(create_executable EXE_NAME SRC_FILE)</div>
<div class="line">    add_executable(${EXE_NAME} ${SRC_FILE})</div>
<div class="line">    target_link_libraries(${EXE_NAME} PRIVATE ${COMMON_LIBS})</div>
<div class="line">endfunction()</div>
<div class="line"> </div>
<div class="line"># Finds pybind11 (doesn&#39;t seem to link with library) and MIDSX</div>
<div class="line">find_package(pybind11 REQUIRED)</div>
<div class="line">find_package(MIDSX REQUIRED)</div>
<div class="line"># Needed for parallelization</div>
<div class="line">find_package(OpenMP REQUIRED)</div>
<div class="line"> </div>
<div class="line"># If unable to find pybind11, manually set the extern directory</div>
<div class="line"># add_subdirectory(../../extern/pybind11 pybind11)</div>
<div class="line"> </div>
<div class="line"># Sets common libs that are linked to executable</div>
<div class="line">set(COMMON_LIBS pybind11::embed MIDSX::MIDSX)</div>
<div class="line"> </div>
<div class="line">create_executable(project main.cpp)</div>
</div><!-- fragment --><p>A typical MIDSX simulation has the following structure:</p>
<ul>
<li>A .json file containing scene information: <div class="fragment"><div class="line">{</div>
<div class="line">  &quot;dim_space&quot;: [</div>
<div class="line">    4,</div>
<div class="line">    4,</div>
<div class="line">    100</div>
<div class="line">  ],</div>
<div class="line">  &quot;background_material_name&quot;: &quot;Air, Dry (near sea level)&quot;,</div>
<div class="line">  &quot;voxel_grids&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;file_path&quot;: &quot;path/to/nifti/file.nii&quot;,</div>
<div class="line">      &quot;origin&quot;: [0, 0, 10]</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Using the .json file, the <code><a class="el" href="class_computational_domain.html" title="Class which represents the computational domain.">ComputationalDomain</a></code> object can be initialized: <div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_computational_domain.html">ComputationalDomain</a> comp_domain(<span class="stringliteral">&quot;domain.json&quot;</span>);</div>
<div class="ttc" id="aclass_computational_domain_html"><div class="ttname"><a href="class_computational_domain.html">ComputationalDomain</a></div><div class="ttdoc">Class which represents the computational domain.</div><div class="ttdef"><b>Definition</b> <a href="computational__domain_8h_source.html#l00022">computational_domain.h:22</a></div></div>
</div><!-- fragment --></li>
<li>The <code><a class="el" href="class_interaction_data.html" title="Class which provides access to various simulation significant data.">InteractionData</a></code> object can either be manually initialized via a list of material names or by calling <code>comp_domain.getInteractionData()</code>, which generates an <code><a class="el" href="class_interaction_data.html" title="Class which provides access to various simulation significant data.">InteractionData</a></code> object using the materials contained in the <code><a class="el" href="class_computational_domain.html" title="Class which represents the computational domain.">ComputationalDomain</a></code> object.</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::vector&lt;std::string&gt; material_names = {<span class="stringliteral">&quot;Air, Dry (near sea level)&quot;</span>, <span class="stringliteral">&quot;Water, Liquid&quot;</span>};</div>
<div class="line"><a class="code hl_class" href="class_interaction_data.html">InteractionData</a> interaction_data(material_names);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_interaction_data.html">InteractionData</a> interaction_data = comp_domain.getInteractionData();</div>
<div class="ttc" id="aclass_interaction_data_html"><div class="ttname"><a href="class_interaction_data.html">InteractionData</a></div><div class="ttdoc">Class which provides access to various simulation significant data.</div><div class="ttdef"><b>Definition</b> <a href="interaction__data_8h_source.html#l00027">interaction_data.h:27</a></div></div>
</div><!-- fragment --><ul>
<li>Using these two objects, the <code><a class="el" href="class_physics_engine.html">PhysicsEngine</a></code> can now be initialized: <div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_physics_engine.html">PhysicsEngine</a> physics_engine(comp_domain, interaction_data);</div>
<div class="ttc" id="aclass_physics_engine_html"><div class="ttname"><a href="class_physics_engine.html">PhysicsEngine</a></div><div class="ttdef"><b>Definition</b> <a href="physics__engine_8h_source.html#l00021">physics_engine.h:21</a></div></div>
</div><!-- fragment --></li>
<li>To make measurements, tallies must be specified. Various <code><a class="el" href="class_surface_tally.html" title="Virtual class which represents a surface tally.">SurfaceTally</a></code> and <code><a class="el" href="class_volume_tally.html" title="Virtual class which represents a volume tally.">VolumeTally</a></code> objects are available, and these objects must be supplied with a <code><a class="el" href="class_surface_quantity_container.html" title="Class which represents a container for surface quantities.">SurfaceQuantityContainer</a></code> or <code>VolumeQuanitityContainer</code> which holds <code>SurfaceQuantity</code>'s and <code>VolumeQuantity</code>'s, respectively, to be measured by the tallies. These containers can be created manually, or predefined containers can be used via <code>SurfaceQuantityContainerFactory</code> or <code>VolumeQuantityContainerFactory</code>. Since these tallies must be constructed in an OpenMP parallel region, you must create seperate functions which return a vector of unique pointers to these tallies.</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line">std::vector&lt;std::unique_ptr&lt;SurfaceTally&gt;&gt; initializeSurfaceTallies() {</div>
<div class="line">    <span class="comment">// Create an empty vector of unique pointers to surface tallies</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;SurfaceTally&gt;&gt; tallies = {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Use the predefined container factory to create a container with all quantities</span></div>
<div class="line">    <span class="comment">// to create a disc surface tally and add it to the vector</span></div>
<div class="line">    surface_tallies.emplace_back(std::make_unique&lt;DiscSurfaceTally&gt;(</div>
<div class="line">                Eigen::Vector3d(2, 2, 100),</div>
<div class="line">                Eigen::Vector3d(0, 0, 1),</div>
<div class="line">                1.0,</div>
<div class="line">                SurfaceQuantityContainerFactory::AllQuantities()));</div>
<div class="line">    <span class="keywordflow">return</span> tallies;</div>
<div class="line">}</div>
<div class="line">std::vector&lt;std::unique_ptr&lt;VolumeTally&gt;&gt; initializeVolumeTallies() {</div>
<div class="line">    <span class="comment">// Create an empty vector of unique pointers to volume tallies</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;VolumeTally&gt;&gt; tallies = {};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Manually create a container with only energy deposition</span></div>
<div class="line">    <span class="keyword">auto</span> volume_container = <a class="code hl_class" href="class_volume_quantity_container.html">VolumeQuantityContainer</a>();</div>
<div class="line">    volume_container.addVectorQuantity(<a class="code hl_class" href="class_vector_volume_quantity.html">VectorVolumeQuantity</a>(VectorVolumeQuantityType::EnergyDeposition));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a cuboid volume tally and add it to the vector</span></div>
<div class="line">    volume_tallies.emplace_back(std::make_unique&lt;AACuboidVolumeTally&gt;(</div>
<div class="line">                Eigen::Vector3d(0, 0, 155),</div>
<div class="line">                Eigen::Vector3d(39.0, 39.0, 175),</div>
<div class="line">                volume_container));</div>
<div class="line">    <span class="keywordflow">return</span> tallies;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_vector_volume_quantity_html"><div class="ttname"><a href="class_vector_volume_quantity.html">VectorVolumeQuantity</a></div><div class="ttdoc">Class which represents a vector quantity for a volume tally.</div><div class="ttdef"><b>Definition</b> <a href="volume__quantity_8h_source.html#l00039">volume_quantity.h:39</a></div></div>
<div class="ttc" id="aclass_volume_quantity_container_html"><div class="ttname"><a href="class_volume_quantity_container.html">VolumeQuantityContainer</a></div><div class="ttdoc">Class which represents a container for volume quantities.</div><div class="ttdef"><b>Definition</b> <a href="volume__quantity__container_8h_source.html#l00015">volume_quantity_container.h:15</a></div></div>
</div><!-- fragment --><ul>
<li>In order to run the simulation, one just needs a way to generate photons. MIDSX uses <code><a class="el" href="class_energy_spectrum.html" title="Virtual class which represents an energy spectrum for a photon source.">EnergySpectrum</a></code>, <code><a class="el" href="class_directionality.html" title="Virtual class which represents a directionality for a photon source.">Directionality</a></code>, and <code><a class="el" href="class_source_geometry.html" title="Virtual class which represents a geometry for a photon source.">SourceGeometry</a></code> objects to build a <code><a class="el" href="class_photon_source.html" title="Class which represents a photon source.">PhotonSource</a></code>.</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="class_monoenergetic_spectrum.html">MonoenergeticSpectrum</a> mono_spectrum(56.4E3);</div>
<div class="line">std::unique_ptr&lt;EnergySpectrum&gt; spectrum = std::make_unique&lt;MonoenergeticSpectrum&gt;(mono_spectrum);</div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;Directionality&gt; directionality = std::make_unique&lt;BeamDirectionality&gt;(</div>
<div class="line">        <a class="code hl_class" href="class_beam_directionality.html">BeamDirectionality</a>(Eigen::Vector3d(39.0/2, 39.0/2, 180)));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::unique_ptr&lt;SourceGeometry&gt; geometry = std::make_unique&lt;PointGeometry&gt;(</div>
<div class="line">        <a class="code hl_class" href="class_point_geometry.html">PointGeometry</a>(Eigen::Vector3d(0.0, dim_space.y()/2.0, dim_space.z()/2.0)));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_photon_source.html">PhotonSource</a> source(std::move(spectrum), std::move(directionality), std::move(geometry));</div>
<div class="ttc" id="aclass_beam_directionality_html"><div class="ttname"><a href="class_beam_directionality.html">BeamDirectionality</a></div><div class="ttdoc">Class which represents a beam directionality.</div><div class="ttdef"><b>Definition</b> <a href="source_8h_source.html#l00115">source.h:115</a></div></div>
<div class="ttc" id="aclass_monoenergetic_spectrum_html"><div class="ttname"><a href="class_monoenergetic_spectrum.html">MonoenergeticSpectrum</a></div><div class="ttdoc">Class which represents a monoenergetic energy spectrum.</div><div class="ttdef"><b>Definition</b> <a href="source_8h_source.html#l00032">source.h:32</a></div></div>
<div class="ttc" id="aclass_photon_source_html"><div class="ttname"><a href="class_photon_source.html">PhotonSource</a></div><div class="ttdoc">Class which represents a photon source.</div><div class="ttdef"><b>Definition</b> <a href="source_8h_source.html#l00241">source.h:241</a></div></div>
<div class="ttc" id="aclass_point_geometry_html"><div class="ttname"><a href="class_point_geometry.html">PointGeometry</a></div><div class="ttdoc">Class which represents a point geometry.</div><div class="ttdef"><b>Definition</b> <a href="source_8h_source.html#l00219">source.h:219</a></div></div>
</div><!-- fragment --><ul>
<li>Now, with <code><a class="el" href="class_photon_source.html" title="Class which represents a photon source.">PhotonSource</a></code>, <code><a class="el" href="class_physics_engine.html">PhysicsEngine</a></code>, and the tally initialization functions, you can use <code>runSimulation</code> to run the simulation:</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NUM_OF_PHOTONS = 1000000;</div>
<div class="line"><a class="code hl_function" href="run__simulation_8h.html#ad0907c789d1306f78691fa483d0dfad1">runSimulation</a>(source, physics_engine, initializeSurfaceTallies,</div>
<div class="line">              initializeVolumeTallies, NUM_OF_PHOTONS);</div>
<div class="ttc" id="arun__simulation_8h_html_ad0907c789d1306f78691fa483d0dfad1"><div class="ttname"><a href="run__simulation_8h.html#ad0907c789d1306f78691fa483d0dfad1">runSimulation</a></div><div class="ttdeci">void runSimulation(PhotonSource &amp;source, PhysicsEngine &amp;physics_engine, std::function&lt; std::vector&lt; std::unique_ptr&lt; SurfaceTally &gt; &gt;()&gt; surface_tally_init, std::function&lt; std::vector&lt; std::unique_ptr&lt; VolumeTally &gt; &gt;()&gt; volume_tally_init, int N_photons, double &amp;run_time= *(new double))</div><div class="ttdoc">Helper function which runs the particle transport simulation.</div></div>
</div><!-- fragment --><ul>
<li>Data can be retrieved from the simulation via <code>physics_engine.getSurfaceQuantityContainers()</code> and <code>physics_engine.getVolumeQuantityContainers()</code>.</li>
<li>For further info, look at the several examples in the <code>cpp_simulations</code> folder. </li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
